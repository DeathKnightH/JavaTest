# IEEE 754 浮点数

## 0. Introduction

​	Java 支持的符合 IEEE 754 规范的单精度和双精度的浮点数。

## 1. Why "FLOAT"?

 	区别于定点数(Fixed point number)，浮点数(Floating point number)使用科学计数法，所表示的小数点位置在数值中的位置是浮动的,，这样能表示更大范围的值(小更趋近于 0 和大更趋近于 $\infty$ )。

​	以下均以**单精度** (即 Java 中的 float) 为例描述，双精度的格式与单精度相同，只是表示范围更大(指数位占 11 bits，分数位占 52 bits)。

## 2. Construction of float

​	对于单精度的浮点数，值由三个部分构成:
$$
Value = sign \times exponent \times fraction
$$
​	其中:

|          | 占位/bits | 描述                           |
| -------- | --------- | ------------------------------ |
| sign     | 1         | 符号位                         |
| exponent | 8         | 指数(采用指数偏差，而不是补码) |
| fraction | 23        | 分数                           |

* 指数偏差(移码/阶码)

  ​	指数需要有符号（即正/负）才能表示极大的数和极小的数，但是如果指数域使用常用的补码形式，在比较指数大小时比较麻烦。

  ​	所以采用了偏差值的方法，即指数域的二进制编码值为所代表的实际值加上 2^(n-1)，其中 n 为指数域的位数。

  ​	例如，在单精度浮点数中，当表示指数为 10 时，编码值应为 137，即 1000 1001。

* 规范格式的浮点数(normal number)

  ​	规范格式的浮点数在指数域不为0，同时分数位隐含了一个尾数 1，这个数被称为 `有效数(significant)` 。例如 0 0000 0001 000 0000 0000 0000 0000 0000 的分数位编码值为 0，但是表示的分数域实际值为 1.0（十进制），此时整体浮点数的值为 1.0 * 2^(-126)。

  ​	这样会导致**突然式下溢出**(abrupt underflow) 问题，参考下面的表格：

  |                | 十进制值                      | 与相邻的更小值的差值 |
  | -------------- | ----------------------------- | -------------------- |
  | 最小规格浮点数 | 2^(-126)                      | 2^(-126)             |
  | 次小规格浮点数 | 2^(-126) + 2^(-23) * 2^(-126) | 2^(-149)             |

  可以看到最小规格浮点数到 0 的距离是到次小规格浮点数的 2^23 倍，这就是突然式下溢出。

* 非规范格式的浮点数(denormal number)

  ​	非规格的浮点数指数域为0，且分数位不为0，同时分数位隐含了一个尾数 0。这样所有的非规格的浮点数的绝对值都小于规格的浮点数。

  ​	denormal number 一定程度上解决了突然式下溢出的问题，最小的 denormal number 的十进制值与 0 的距离为 2^(-149)，这与到次小 denormal number 的距离是相等的。

  ​	这样也会产生一个特性，当 float 的实际绝对值在 (0,1)之间时，精度比表示其他数时要高。

## 3. Value range of float

|            | 描述          | 十进制         | sign | exponent  | fraction                     |
| ---------- | ------------- | -------------- | ---- | --------- | ---------------------------- |
| NaN        | 非数值        |                | *    | 1111 1111 | 非0                          |
| +0         | 符号位为正的0 | 0.0            | 0    | 0000 0000 | 000 0000 0000 0000 0000 0000 |
| -0         | 符号位为负的0 | -0.0           | 1    | 0000 0000 | 000 0000 0000 0000 0000 0000 |
| 1          | 1             | 1.0            | 0    | 0111 1111 | 000 0000 0000 0000 0000 0000 |
| -1         | -1            | -1.0           | 1    | 0111 1111 | 000 0000 0000 0000 0000 0000 |
| +$\infty$  | 正无穷        |                | 0    | 1111 1111 | 000 0000 0000 0000 0000 0000 |
| -$\infty$  | 负无穷        |                | 1    | 1111 1111 | 000 0000 0000 0000 0000 0000 |
| Max_value  | 最大正值      | 3.4028235e+38  | 0    | 1111 1110 | 111 1111 1111 1111 1111 1111 |
| Min_normal | 最小正标准值  | 1.17549435e-38 | 0    | 0000 0001 | 000 0000 0000 0000 0000 0000 |
| Min_value  | 最小正值      | 1.4e-45        | 0    | 0000 0000 | 000 0000 0000 0000 0000 0001 |

* 最小值和最小标准值的区别

  规则定义**指数位**(exponent)为0，但分数位(fraction)不为0时，此时表示的值为非标准形式的浮点数，通常用于表示非常趋近于 0 的浮点数。

  这是为了解决**突然式下溢出**(abrupt underflow) 问题，Intel 公司提出的**渐进式下溢出**(gradual underflow)方案。